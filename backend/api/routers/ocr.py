from __future__ import annotations

import logging
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from api.dependencies import get_paddleocr_client
from fastapi import APIRouter, Depends, File, HTTPException, UploadFile, status
from fastapi.concurrency import run_in_threadpool
from pydantic import BaseModel, Field, ValidationError
from services.paddleocr import (
    PaddleOcrService,
    PaddleOcrServiceError,
    PaddleOcrUploadConstraints,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/ocr", tags=["ocr"])


class OcrElement(BaseModel):
    index: int = Field(..., description="Element index in the document response")
    content: Dict[str, Any] = Field(
        default_factory=dict, description="Content payload returned by PaddleOCR-VL"
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Metadata (bbox, confidence, type, etc.)"
    )


class OcrConstraints(BaseModel):
    allow_any_extension: bool = Field(
        ..., description="Whether every extension is accepted before proxying"
    )
    allowed_extensions: List[str] = Field(
        default_factory=list,
        description="Normalised list of allowed extensions (lowercase, with dot)",
    )
    max_file_size_bytes: int = Field(
        ..., description="Maximum upload size enforced before proxying"
    )
    max_file_size_mb: float = Field(..., description="Maximum upload size in MB")


class OcrExtractionResponse(BaseModel):
    success: bool = Field(..., description="Whether the OCR processing succeeded")
    message: str = Field(..., description="Status message from PaddleOCR-VL")
    processing_time: float = Field(..., description="Processing time in seconds")
    elements: List[OcrElement] = Field(
        default_factory=list, description="Extracted OCR elements"
    )
    markdown: Optional[str] = Field(
        None, description="Markdown representation of the extracted content"
    )
    timestamp: Optional[datetime] = Field(
        None, description="Timestamp emitted by PaddleOCR-VL"
    )


class OcrHealthResponse(BaseModel):
    status: str = Field(..., description="Service status reported by PaddleOCR-VL")
    service: str = Field(..., description="Service name")
    version: str = Field(..., description="Service version")
    gpu_enabled: bool = Field(
        ..., description="Whether GPU is available to the service"
    )
    pipeline_ready: bool = Field(
        ..., description="Whether PaddleOCR-VL has initialised its pipeline"
    )
    timestamp: Optional[datetime] = Field(
        None, description="Timestamp reported by the service"
    )
    constraints: OcrConstraints = Field(
        ..., description="Upload constraints enforced by the backend proxy"
    )


class OcrDisabledResponse(BaseModel):
    status: str = Field("disabled", description="Indicates OCR integration is disabled")
    service: str = Field("PaddleOCR-VL", description="Service name")
    version: str = Field("n/a", description="Service version when disabled")
    gpu_enabled: bool = Field(False, description="GPU status when integration disabled")
    pipeline_ready: bool = Field(False, description="Pipeline status when disabled")
    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp generated by the backend when disabled",
    )
    constraints: OcrConstraints = Field(
        ..., description="Upload constraints enforced by the backend proxy"
    )


def _format_constraints(constraints: PaddleOcrUploadConstraints) -> OcrConstraints:
    allowed = sorted(constraints.allowed_extensions)
    return OcrConstraints(
        allow_any_extension=constraints.allow_any,
        allowed_extensions=allowed,
        max_file_size_bytes=constraints.max_file_size_bytes,
        max_file_size_mb=round(constraints.max_file_size_bytes / (1024 * 1024), 2),
    )


def _validate_extension(
    filename: str | None, constraints: PaddleOcrUploadConstraints
) -> None:
    if not filename:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Uploaded file must include a filename.",
        )

    if constraints.allow_any:
        return

    extension = Path(filename).suffix.lower()
    if extension not in constraints.allowed_extensions:
        allowed = ", ".join(sorted(constraints.allowed_extensions))
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Unsupported file extension '{extension}'. Allowed extensions: {allowed}",
        )


def _validate_size(data: bytes, constraints: PaddleOcrUploadConstraints) -> None:
    size = len(data)
    if size == 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, detail="Uploaded file is empty."
        )

    if size > constraints.max_file_size_bytes:
        limit_mb = constraints.max_file_size_bytes / (1024 * 1024)
        raise HTTPException(
            status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,
            detail=f"File too large. Maximum supported size is {limit_mb:.1f} MB.",
        )


@router.post(
    "/extract",
    response_model=OcrExtractionResponse,
    summary="Extract document structure with PaddleOCR-VL",
)
async def extract_document(
    file: UploadFile = File(..., description="Image or PDF file to process"),
    client: PaddleOcrService = Depends(get_paddleocr_client),
):
    """
    Proxy document extraction requests to PaddleOCR-VL.

    Validates file size and extension locally before forwarding the upload.
    """
    if not client.is_enabled():
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="PaddleOCR-VL integration is disabled.",
        )

    constraints = client.upload_constraints()

    _validate_extension(file.filename, constraints)
    file_bytes = await file.read()
    _validate_size(file_bytes, constraints)

    try:
        result = await run_in_threadpool(
            client.extract_document,
            file_bytes,
            filename=file.filename or "upload.bin",
            content_type=file.content_type,
        )
    except PaddleOcrServiceError as exc:
        status_code = exc.status_code or status.HTTP_502_BAD_GATEWAY
        logger.warning("PaddleOCR-VL request failed: %s", exc)
        raise HTTPException(status_code=status_code, detail=str(exc)) from exc
    except Exception as exc:  # pragma: no cover - fallback guard
        logger.exception("Unexpected error calling PaddleOCR-VL: %s", exc)
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,
            detail="Unexpected error contacting PaddleOCR-VL service.",
        ) from exc

    try:
        return OcrExtractionResponse.model_validate(result)
    except ValidationError as exc:
        logger.error("Invalid response from PaddleOCR-VL: %s", exc)
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,
            detail="Received an invalid response from PaddleOCR-VL.",
        ) from exc


@router.get(
    "/health",
    response_model=OcrHealthResponse | OcrDisabledResponse,
    summary="Check PaddleOCR-VL health",
)
async def ocr_health(client: PaddleOcrService = Depends(get_paddleocr_client)):
    """
    Report health information about the PaddleOCR-VL integration.
    """
    constraints = _format_constraints(client.upload_constraints())

    if not client.is_enabled():
        return OcrDisabledResponse(constraints=constraints)

    try:
        data = await run_in_threadpool(client.health)
    except PaddleOcrServiceError as exc:
        status_code = exc.status_code or status.HTTP_502_BAD_GATEWAY
        logger.warning("PaddleOCR-VL health check failed: %s", exc)
        raise HTTPException(status_code=status_code, detail=str(exc)) from exc
    except Exception as exc:  # pragma: no cover - fallback guard
        logger.exception("Unexpected error calling PaddleOCR-VL health: %s", exc)
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,
            detail="Unexpected error contacting PaddleOCR-VL health endpoint.",
        ) from exc

    payload = dict(data)
    payload["constraints"] = constraints.model_dump()

    try:
        return OcrHealthResponse.model_validate(payload)
    except ValidationError as exc:
        logger.error("Invalid health payload from PaddleOCR-VL: %s", exc)
        raise HTTPException(
            status_code=status.HTTP_502_BAD_GATEWAY,
            detail="Received an invalid health response from PaddleOCR-VL.",
        ) from exc
