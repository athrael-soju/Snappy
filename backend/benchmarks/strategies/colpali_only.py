"""
ColPali-only retrieval strategy.

Uses only ColPali vision-language embeddings without OCR or region relevance.
"""

import asyncio
import logging
import time
from typing import Any, Dict, List

import requests

from benchmarks.strategies.base import BaseRetrievalStrategy, RetrievalResult

logger = logging.getLogger(__name__)


class ColPaliOnlyStrategy(BaseRetrievalStrategy):
    """
    ColPali-only retrieval strategy.

    This implements a simpler pipeline using only vision-language embeddings:
    1. Query embedding via ColPali
    2. Vector search in Qdrant
    3. Return retrieved page images (no OCR text extraction)

    Context for RAG is generated by describing the retrieved images
    or using a VLM to extract text.
    """

    def __init__(
        self,
        colpali_url: str = "http://localhost:7000",
        qdrant_url: str = "http://localhost:6333",
        collection_name: str = "benchmark_documents",
        use_mean_pooling: bool = True,
        prefetch_limit: int = 100,
        # VLM settings for context extraction
        use_vlm_for_context: bool = True,
        vlm_prompt: str = "Extract all text content from this document image.",
        **kwargs,
    ):
        super().__init__(
            colpali_url=colpali_url,
            qdrant_url=qdrant_url,
            collection_name=collection_name,
            **kwargs,
        )

        self.use_mean_pooling = use_mean_pooling
        self.prefetch_limit = prefetch_limit
        self.use_vlm_for_context = use_vlm_for_context
        self.vlm_prompt = vlm_prompt

        self._colpali_client = None
        self._session = None

    @property
    def name(self) -> str:
        return "colpali_only"

    @property
    def description(self) -> str:
        return (
            "ColPali-only strategy using vision-language embeddings "
            "without OCR-based region extraction"
        )

    async def initialize(self) -> None:
        """Initialize ColPali client."""
        from clients.colpali import ColPaliClient

        self._colpali_client = ColPaliClient(
            base_url=self.colpali_url,
            timeout=60,
        )

        self._session = requests.Session()

        health = await self.health_check()
        if not health.get("colpali"):
            raise RuntimeError("ColPali service not healthy")

        self._initialized = True
        self._logger.info("ColPaliOnlyStrategy initialized")

    async def health_check(self) -> Dict[str, bool]:
        """Check ColPali service health."""
        health = {}

        try:
            if self._colpali_client:
                health["colpali"] = self._colpali_client.health_check()
            else:
                health["colpali"] = False
        except Exception:
            health["colpali"] = False

        try:
            response = self._session.get(f"{self.qdrant_url}/healthz", timeout=5)
            health["qdrant"] = response.status_code == 200
        except Exception:
            health["qdrant"] = False

        return health

    async def retrieve(
        self,
        query: str,
        top_k: int = 5,
        **kwargs,
    ) -> RetrievalResult:
        """
        Retrieve relevant documents using ColPali embeddings only.

        Args:
            query: Search query text
            top_k: Number of results to retrieve

        Returns:
            RetrievalResult with retrieved pages (no OCR context)
        """
        result = RetrievalResult()
        total_start = time.perf_counter()

        try:
            # Step 1: Generate query embedding
            embed_start = time.perf_counter()
            query_embedding = await asyncio.to_thread(
                self._colpali_client.embed_queries, query
            )
            result.embedding_time_ms = (time.perf_counter() - embed_start) * 1000

            # Step 2: Vector search in Qdrant
            search_start = time.perf_counter()
            search_results = await self._search_qdrant(query_embedding[0], top_k)
            search_time = (time.perf_counter() - search_start) * 1000

            if not search_results:
                result.error = "No search results found"
                return result

            # Step 3: Process results
            image_urls = []
            for item in search_results:
                payload = item.get("payload", {})
                score = item.get("score", 0.0)

                result.retrieved_pages.append(payload.get("pdf_page_index", 0))
                result.scores.append(score)

                image_url = payload.get("image_url")
                if image_url:
                    image_urls.append(image_url)

            # For ColPali-only, context is either:
            # 1. Image URLs for VLM to process
            # 2. Empty (pure visual retrieval without text)
            if self.use_vlm_for_context:
                # Store image URLs as context - VLM will process during RAG
                result.context_text = f"[IMAGES:{','.join(image_urls)}]"
            else:
                result.context_text = ""

            result.raw_response = {
                "search_results": search_results,
                "image_urls": image_urls,
            }

        except Exception as e:
            result.error = str(e)
            self._logger.error(f"Retrieval failed: {e}", exc_info=True)

        result.retrieval_time_ms = (time.perf_counter() - total_start) * 1000

        return result

    async def _search_qdrant(
        self, query_embedding: List[List[float]], top_k: int
    ) -> List[Dict[str, Any]]:
        """Execute vector search in Qdrant."""
        if self.use_mean_pooling:
            request = {
                "query": query_embedding,
                "prefetch": [
                    {
                        "query": query_embedding,
                        "limit": self.prefetch_limit,
                        "using": "mean_pooling_columns",
                    },
                    {
                        "query": query_embedding,
                        "limit": self.prefetch_limit,
                        "using": "mean_pooling_rows",
                    },
                ],
                "limit": top_k,
                "with_payload": True,
                "using": "original",
            }
        else:
            request = {
                "query": query_embedding,
                "limit": top_k,
                "with_payload": True,
                "using": "original",
            }

        response = await asyncio.to_thread(
            self._session.post,
            f"{self.qdrant_url}/collections/{self.collection_name}/points/query",
            json=request,
            timeout=30,
        )

        if response.status_code != 200:
            raise RuntimeError(f"Qdrant search failed: {response.text}")

        data = response.json()
        points = data.get("result", {}).get("points", [])

        return [
            {"payload": p.get("payload", {}), "score": p.get("score", 0.0)}
            for p in points
        ]

    async def index_documents(
        self,
        documents: List[Dict[str, Any]],
        **kwargs,
    ) -> bool:
        """Index documents (same as Snappy, but could skip OCR)."""
        self._logger.warning(
            "ColPaliOnlyStrategy uses shared indexing pipeline. "
            "Documents should be indexed via SnappyFullStrategy."
        )
        return True

    async def cleanup(self) -> None:
        """Clean up resources."""
        if self._session:
            self._session.close()
        await super().cleanup()
